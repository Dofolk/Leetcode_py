# 這題是要算看看 1~n 的數字做成二元搜尋樹(BST)有幾種可能性
# 想法就是來算左右子樹的數量，左右子樹可能的數量相乘就會是該 root 的可能性
# 所以第一個 for 就是來看看要算幾個數字的，第二個 for 就是開始計算左右子樹的數量後相加
# 在程式碼中的 dp[j] 就是指在左子樹的節點數量是 j 的時候有多少總形狀的可能性
# 而右子樹的 dp[i-1-j] 就是補集，把剩下的節點數的子數算完
# 最後兩個相乘就是在指定左右子樹節點數量的可能個數，最後全部(1~i)加起來就可以了

class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2,n+1):
            for j in range(i):
                dp[i] += dp[j] * dp[i-1-j]
        return dp[-1]
